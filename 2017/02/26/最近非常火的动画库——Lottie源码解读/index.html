<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>最近非常火的动画库——Lottie源码解读 | Turtle的技术世界</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Turtle的技术世界">
    <meta name="author" content="Turtle">
    <meta name="description" content="iOS中级开发者 & 前端刚入门" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Turtle的技术世界" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
	
    <link rel="stylesheet" href="/highlightjs/pojoaque.css" type="text/css">
    


    <!-- Custom stylesheet, (add custom styles here, always load last) -->
    <!-- Load our stylesheet for IE8 -->
    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- Google Webfonts (Monserrat 400/700, Open Sans 400/600) -->
    <!-- <link href='//fonts.useso.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
    <link href='//fonts.useso.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->

    <!-- Load our fonts individually if IE8+, to avoid faux bold & italic rendering -->
    <!--[if IE]>
    <link href='http://fonts.useso.com/css?family=Montserrat:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Montserrat:700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:600' rel='stylesheet' type='text/css'>
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->










  
  
  

  
  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="http://blog.gocy.tech/" class="animsition-link">Gocy</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/turtle.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Turtle的技术世界</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/dark19940411" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li><a href="http://weibo.com/1950154683/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2017-02-26T09:39:59.000Z" itemprop="datePublished">
          2017-02-26
      </time>
    
</span>
                <h1>最近非常火的动画库——Lottie源码解读</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<p>Yep，finally，eventually，迎来了我的第一篇源码解读类的文章。相比之前粗略看过的ASDK，Lottie可谓是<strong>对开发者来说十分之不友好</strong>——因为几乎没有注释，本文作为自己的学习记录，也给大家参考。</p>
<h3 id="从Lottie的官方Demo讲起"><a href="#从Lottie的官方Demo讲起" class="headerlink" title="从Lottie的官方Demo讲起"></a>从Lottie的官方Demo讲起</h3><p>Lottie的<a href="https://github.com/airbnb/lottie-ios" target="_blank" rel="external">官方Demo</a>的一开始是一个很酷炫的header，以及一个只有三行的tableView：<br><img src="/images/Lottie1.gif" alt=""><br>从每一行里点进去就发现第二个是一个打字相关的动画（显然作者把A-Z的字母显示都用AfterEffects做了一套动画用在了这里），第三行则是一个页面切换的动画。第一行里则是一个让你浏览整个demo里用到的动画的view——这里的动画甚至不是播放的，而是可以自己拖动进度条来带动变化。在第一第二行对应的demo里着重用到了lottie里的一个类——LOTAnimationView来显示动画，而在Animated Transition Demo中则是着重使用LOTAnimationTransitionController，跳到LOTAnimationTransitionController里看一看，原来这个controller不过是一个实现了<code>&lt;UIViewControllerAnimatedTransitioning&gt;</code>协议，结合LOTAnimationView来实现页面动画切换的一个类而已。  </p>
<p>所以，非常明显，Lottie始于LOTAnimationView。  </p>
<p>在我们开始进一步地阅读Lottie的源码之前，我们必须得搞明白Lottie总的来说干了什么，还有我写这篇文章的目的是什么。首先Lottie的作用就是你输入一个由AE制作的动画再由其插件bodymovin转成的JSON，然后Lottie就将里面的动画添加到LOTAnimationView之上并返还给你。<br><img src="/images/Lottie主线.png" alt=""><br>都说阅读源码就像拼图，一块块的找到缺失的拼图块，最后把拼图完成，你也就读懂了这个源码，而这幅示意图就是拼图的主线。所以现在我们知道，Lottie干了两件事——接收JSON文件解析获得数据，并把数据用来生成动画并最后返回给你一个可视的view。而这篇文章的目的，是要告诉你它是怎么获得数据的，获得了哪些数据，怎么封装的，还有整个项目的结构以及它用到的核心技术。Lottie生成动画的核心技术是使用了苹果的动画库Core Animation，但是由于我才疏学浅，对Core Animation了解不深，所以也是边查边阅读的源码，如有理解上的错误还望指出纠正。（然而目前我的博客还没有评论功能，我会尽快加上的！） </p>
<p>那么，正文开始。哦还有，本文解析的是Lottie-iOS，如果想看别的版本的解析，请移步别处，并且Lottie里关于Mac OS的部分，只会有少量的解释甚至不解释。</p>
<h3 id="从LOTAnimationView的初始化讲起"><a href="#从LOTAnimationView的初始化讲起" class="headerlink" title="从LOTAnimationView的初始化讲起"></a>从LOTAnimationView的初始化讲起</h3><p>看到源码，我们可以发现LOTAnimationView继承自LOTView，LOTView实际上只是个一个换名的类，对于iOS而言LOTView就是UIView，对于MacOS而言，就是NSView，显然它是为了适配Mac而存在的。<br>打开LOTAnimationView.m，看到类方法：<br><code>+ (instancetype)animationNamed:(NSString *)animationName</code><br>这毕竟是一个专门用来初始化的工厂方法，很好用来作为开始，代码也很好懂，animationName就是JSON文件对应的名字，方法最开始先取出文件的名字，然后从LOTAnimationCache里取出LOTComposition的缓存，先将后者放到一边，结合<a href="https://github.com/airbnb/lottie-ios" target="_blank" rel="external">官方文档</a>所提到的<strong>LRU缓存策略</strong>，我们来讲讲LOTAnimationCache。  </p>
<h4 id="LRU（Least-Recently-Used）——LOTAnimationCache"><a href="#LRU（Least-Recently-Used）——LOTAnimationCache" class="headerlink" title="LRU（Least Recently Used）——LOTAnimationCache"></a>LRU（Least Recently Used）——LOTAnimationCache</h4><p>打开LOTAnimationCache.h，可以看到这是一个单例，还有简单的存取方法。下移一格，来到LOTAnimationCache.m，我们可以看到它只有两个ivar，一个<code>NSMutableDictionary *animationsCache_</code>和一个<code>NSMutableArray *lruOrderArray_</code>。如果你学过操作系统，你就知道<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="external">LRU算法</a>是一种淘汰最近最少使用的项目的算法。而LOTAnimationCache的字典用来存放&lt;动画名，LOTComposition&gt;的数据，而lruOrderArray_则是维持了一个lru序列，里面全是动画名。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addAnimation:(LOTComposition *)animation forKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> (lruOrderArray_.count &gt;= <span class="number">50</span>) &#123;</div><div class="line">        <span class="built_in">NSString</span> *oldKey = lruOrderArray_[<span class="number">0</span>];</div><div class="line">        [animationsCache_ removeObjectForKey:oldKey];</div><div class="line">        [lruOrderArray_ removeObject:oldKey];</div><div class="line">    &#125;</div><div class="line">    [lruOrderArray_ removeObject:key];</div><div class="line">    [lruOrderArray_ addObject:key];</div><div class="line">    [animationsCache_ setObject:animation forKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码来看，缓存最多存储50个动画，最近使用的动画放在lru序列的最末端，最少使用的放在序列的开始，便于淘汰。简简单单50多行代码，便实现了一个LRU缓存，存储的对象还可以是各种酷炫的动画，实在是太简洁了。但是之所以这个cache可以这么简洁，也是因为动画的数据早已被完整地封装在了LOTComposition里了。  </p>
<h3 id="核心数据层——LOTComposition和LOTLayer"><a href="#核心数据层——LOTComposition和LOTLayer" class="headerlink" title="核心数据层——LOTComposition和LOTLayer"></a>核心数据层——LOTComposition和LOTLayer</h3><p>从项目的结构上看，LOTComposition放在Models文件夹下，那么它是一个数据层。其次它被用来直接初始化LOTAnimationView(<code>- (instancetype)initWithModel:(LOTComposition *)model</code>)，而且cache存放的对象就是它，所以它代表着一个动画的数据。让我们看看LOTComposition都有些什么样的属性，看看一个完整的动画都需要哪些数据。composition有一个装了多个LOTLayer的数组，还有一些属性，分别代表动画区域、开始／结束帧、帧率、动画时长。所有的这些数据，都源于对JSON文件的解析，然后特定的属性对应了一些特定的key，这些都是bodymovin约定好了的，知道这些key就可以获取到对应的数据，这些从LOTComposition的实现就可以看出来。<br>在LOTComposition的属性里，其他的都很好理解，只有一个<br><code>@property (nonatomic, readonly) NSArray &lt;LOTLayer *&gt; *layers</code><br>让人不能一眼看明白。LOTLayer一开始让我也非常困惑，它看起来似乎像是CALayer的子类，而且看起来它是实现动画了的地方。实则不然，它依然存放在models文件夹下，而且它继承自NSObject，所以说，这依然是一个数据类，而它存放的则是一个图层的动画所需要的数据。而一个复杂的动画可能会由多个layer的动画组合而成，这就是为什么composition里面会有一个装了多个LOTLayer的数组。至于LOTLayer里有些什么数据，又是干什么的，我这里先不说，请接着往下看。  </p>
<p>来到+animationNamed：的最后一行，我们看到调用了<code>-initWithModel:</code>初始化函数。为了方便大家理解LOTAnimationView的初始化干了什么，下面贴上带有我的注释的<code>-initWithModel:</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithModel:(LOTComposition *)model &#123;</div><div class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:model.compBounds];</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    <span class="comment">//初始化AnimationContainer，这是一个展示动画的CALayer容器</span></div><div class="line">    [<span class="keyword">self</span> _initializeAnimationContainer];</div><div class="line">   <span class="comment">//用LOTComposition对self进行配置</span></div><div class="line">   <span class="comment">//主要是往_animationContainer添加带有动画效果的LOTLayerView、寄存各layer和寄存动画的状态</span></div><div class="line">    [<span class="keyword">self</span> _setupWithSceneModel:model restoreAnimationState:<span class="literal">NO</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>-initWithModel:</code>方法里主要执行了两个方法，第一个方法主要是为了初始化动画的容器<code>CALayer *_animationContainer</code>；第二个方法，我们主要讲讲其中是如何初始化带有动画效果的LOTLayerView并将它们添加到_animationContainer中的，藉此我们可以顺便一窥LOTLayerView的究竟。下面先贴一个经我简化的<code>- (void)_buildSubviewsFromModel</code>方法，这是LOTAnimationView利用初始化好的LOTComposition来初始化动画图层的方法，它在<code>_setupWithSceneModel:restoreAnimationState:</code>中被调用（注意看我在代码上加的注释，已经很好地解释了这段代码的作用）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)_buildSubviewsFromModel &#123;</div><div class="line">  </div><div class="line">  <span class="comment">//一串清除旧动画的代码</span></div><div class="line">  </div><div class="line">  <span class="comment">//调整动画容器的仿射变换和大小</span></div><div class="line">  _animationContainer.transform = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">  _animationContainer.bounds = _sceneModel.compBounds;  </div><div class="line">  </div><div class="line">  <span class="comment">//初始化存放动画图层的字典</span></div><div class="line">  <span class="built_in">NSMutableDictionary</span> *layerMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">  <span class="built_in">NSMutableDictionary</span> *layerNameMap = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">  </div><div class="line">  <span class="comment">//我也不知道为啥要取倒序，在LOTComposition里初始化layers的时候是正序的</span></div><div class="line">  <span class="comment">//说明取出来的layer可能是由顶至底排布的吧...</span></div><div class="line">  <span class="built_in">NSArray</span> *reversedItems = [[_sceneModel.layers reverseObjectEnumerator] allObjects];</div><div class="line">  </div><div class="line">  LOTLayerView *maskedLayer = <span class="literal">nil</span>;</div><div class="line">  </div><div class="line">  <span class="comment">//来了，这个for循环就是将LOTCompostion里的layers逐个取出用来初始化成一个个的LOTLayerView</span></div><div class="line">  <span class="comment">//并将它们加到_animationContainer上</span></div><div class="line">  <span class="comment">//LOTLayerView是真正运用了动画的地方，继承自CALayer，所以它本质上是一个layer而非view</span></div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (LOTLayer *layer <span class="keyword">in</span> reversedItems) &#123;</div><div class="line">    LOTLayerView *layerView = [[LOTLayerView alloc] initWithModel:layer inComposition:_sceneModel];</div><div class="line">    layerMap[layer.layerID] = layerView;</div><div class="line">    layerNameMap[layer.layerName] = layerView;  </div><div class="line">    </div><div class="line">    <span class="comment">//这个if-else也让人比较困惑，这是因为有些layer是有mask的</span></div><div class="line">    <span class="comment">//在for循环里如果找到一个有mask的layer，就将它设为maskedLayer</span></div><div class="line">    <span class="comment">//在下一个循环里的layer就必然是它的mask，到时就将它设为maskedLayer.mask</span></div><div class="line">    <span class="keyword">if</span> (maskedLayer) &#123;</div><div class="line">      maskedLayer.mask = layerView;</div><div class="line">      maskedLayer = <span class="literal">nil</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (layer.matteType == LOTMatteTypeAdd) &#123;</div><div class="line">        maskedLayer = layerView;</div><div class="line">      &#125;</div><div class="line">      [_animationContainer addSublayer:layerView];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  _layerMap = layerMap;</div><div class="line">  _layerNameMap = layerNameMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看了上面的代码，我想你应该明白了LOTAnimationView是如何控制好数据层和动画层的关系，而且上面也引入了一个重要的类——LOTLayerView——它本质上是一个CALayer，也是真正运用了动画的地方。那么在LOTLayerView里一定也有许多有趣的动画技术等着我们去了解，但在我们更加深入之前，我们得理清一下我们现在所接触到的类以及它们的关系。<br><img src="/images/Lottie-chaos.jpg" alt=""><br>一直看着代码和文字解释一定让人头昏脑胀，现在让我贴上一张关系示意图：<br><img src="/images/LOTAnimationView里的动画层和数据层关系图.png" alt=""><br>从图中来看，下半部分是一个整合了所有动画图层的view和所有的动画图层LOTLayerView，上半部分则是两个数据大头LOTComposition和LOTLayer。外部数据JSON从LOTAnimationView中流入，被解析进入到LOTComposition和LOTLayer里，最后LOTAnimationView再利用解析好的LOTLayer初始化所有的图层LOTLayerView并添加到自己的CALayer容器里，那么一个从AE里导出的动画就生成了。  </p>
<h3 id="动画层——LOTLayerView"><a href="#动画层——LOTLayerView" class="headerlink" title="动画层——LOTLayerView"></a>动画层——LOTLayerView</h3><p>LOTLayerView，我们依然从它的初始化方法看起。<br><code>-initWithModel:inComposition:</code>没啥特别，存储两份数据到ivar里，然后开始配置自身。来看<code>-(void)_setupViewFromModel</code>，这个方法非常长，我试着在能解释清它是什么的基础上尽量删减。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">	- (<span class="keyword">void</span>)_setupViewFromModel &#123;</div><div class="line">  <span class="comment">//省略代码，配置自身基本属性</span></div><div class="line">  </div><div class="line">  <span class="comment">//看来LOTLayerView和LOTAnimationView一样，都有一个CALayer作为容器</span></div><div class="line">  _childContainerLayer = [<span class="built_in">CALayer</span> new];</div><div class="line">  _childContainerLayer.bounds = <span class="keyword">self</span>.bounds;</div><div class="line">  _childContainerLayer.backgroundColor = _layerModel.solidColor.CGColor;</div><div class="line"></div><div class="line">  <span class="comment">//solid应该是一个背景色图层</span></div><div class="line">  <span class="keyword">if</span> (_layerModel.layerType == LOTLayerTypeSolid) &#123;</div><div class="line">    _childContainerLayer.bounds = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, _layerModel.solidWidth.floatValue, _layerModel.solidHeight.floatValue);</div><div class="line">    _childContainerLayer.backgroundColor = <span class="literal">nil</span>;</div><div class="line">    _childContainerLayer.masksToBounds = <span class="literal">NO</span>;</div><div class="line"></div><div class="line">    <span class="built_in">CALayer</span> *solid = [<span class="built_in">CALayer</span> new];</div><div class="line">    solid.backgroundColor = _layerModel.solidColor.CGColor;</div><div class="line">    solid.frame = _childContainerLayer.bounds;</div><div class="line">    solid.masksToBounds = <span class="literal">YES</span>;</div><div class="line">    [_childContainerLayer addSublayer:solid];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//这是一个疑难part，一个注释说不清楚，将在下面讲解，打上标记1⃣️</span></div><div class="line">  <span class="built_in">NSNumber</span> *parentID = _layerModel.parentID;</div><div class="line">  <span class="built_in">CALayer</span> *currentChild = _childContainerLayer;</div><div class="line">  <span class="built_in">NSMutableArray</span> *parentLayers = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">  <span class="keyword">if</span> (parentID) &#123;</div><div class="line">    <span class="keyword">while</span> (parentID != <span class="literal">nil</span>) &#123;</div><div class="line">      LOTLayer *parentModel = [_composition layerModelForID:parentID];</div><div class="line">      LOTParentLayer *parentLayer = [[LOTParentLayer alloc] initWithParentModel:parentModel inComposition:_composition];</div><div class="line">      [parentLayer addSublayer:currentChild];</div><div class="line">      [parentLayers addObject:parentLayer];</div><div class="line">      currentChild = parentLayer;</div><div class="line">      parentID = parentModel.parentID;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (parentLayers.count) &#123;</div><div class="line">    _parentLayers = parentLayers;</div><div class="line">  &#125;</div><div class="line">  [<span class="keyword">self</span> addSublayer:currentChild];</div><div class="line">  </div><div class="line">  <span class="comment">//设置容器layer的基本属性的初始值，即动画开始前的值</span></div><div class="line">  _childContainerLayer.opacity = _layerModel.opacity.initialValue.floatValue;</div><div class="line">  _childContainerLayer.position = _layerModel.position.initialPoint;</div><div class="line">  _childContainerLayer.anchorPoint = _layerModel.anchor.initialPoint;</div><div class="line">  _childContainerLayer.transform = _layerModel.scale.initialScale;</div><div class="line">  _childContainerLayer.sublayerTransform = <span class="built_in">CATransform3DMakeRotation</span>(_layerModel.rotation.initialValue.floatValue, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">self</span>.hidden = _layerModel.hasInAnimation;</div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="comment">//这里省略一大段代码，取出LOTLayer里会出现的形状，这时候终于涉及到Models文件夹里的诸多数据模型</span></div><div class="line">  <span class="comment">//还有AnimatableLayer文件夹下的各种各样的图层</span></div><div class="line">  <span class="comment">//这里就是用Models下的各种类型的shape数据来对应生成的带动画的layer，并加到container上</span></div><div class="line">  <span class="comment">//为了清楚的解释这里发生了什么，也先打上标记2⃣️，稍后解释</span></div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="comment">//如果有mask动画，则加上</span></div><div class="line">  <span class="keyword">if</span> (_layerModel.masks) &#123;</div><div class="line">    _maskLayer = [[LOTMaskLayer alloc] initWithMasks:_layerModel.masks inComposition:_composition];</div><div class="line">    _childContainerLayer.mask = _maskLayer;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//这段代码不明其意，不知道是不是开发到一半commit了</span></div><div class="line">  <span class="built_in">NSMutableArray</span> *childLayers = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">  [childLayers addObjectsFromArray:_parentLayers];</div><div class="line">  [childLayers addObjectsFromArray:_shapeLayers];</div><div class="line">  <span class="keyword">if</span> (_maskLayer) &#123;</div><div class="line">    [childLayers addObject:_maskLayer];</div><div class="line">  &#125;</div><div class="line">	<span class="comment">//构建动画</span></div><div class="line">  [<span class="keyword">self</span> _buildAnimations];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，大意知道了，我们可以深入聊一下刚刚打了标记的两个代码块。首先说说1⃣️标记的while循环。  </p>
<p>首先，从前文我们就知道了Lottie会在LOTAnimationView里根据LOTLayer初始化所有的LOTLayerView，但是这里的while循环很奇怪，这里说明每个LOTLayerView还会随着LOTLayer里的parentID通过LOTComposition找到一个父LOTLayer来初始化一个LOTParentLayer（这玩意本质和LOTLayerView一样，都是带有动画的CALayer），然后将子layer加到父layer之上，在while循环里重复这个操作直到找到祖先为止。那所有的LOTLayerView叠加到LOTAnimationView之上并非都是单一的图层，每个LOTLayerView又有自己的一条图层链，而且LOTLayerView的图层链里的图层又有可能和别的LOTAnimationView的图层链里的某个图层在数据上一模一样（内存不一样）。这里绕得都快可以rap出来了，所以我决定举例子再解释一遍。  </p>
<p>来看一个极端情况：<br><img src="/images/LOTLayerView里的图层链极端例子.png" alt=""><br>如图，假设一个动画总共有三个图层，然后关系是1是2的父，2是3的父。那么我们来看看它们最后在LOTAnimationView上生成的结果是什么样的：<br><img src="/images/LOTLayerView例子生成结果.png" alt=""><br>这就是最后会在LOTAnimationView上会生成的三个LOTLayerView，第一个layerView挺正常的，但是到了第二个layerView里，我们发现会存在一个和第一个layerView里用同样的LOTLayer生成layer，第三个layerView里面则有两个重复layer。这样做不觉得很浪费内存么？既然这些layer从值上是一模一样的，为什么不干脆共用呢？  </p>
<p>这里有一个原因是，子layer的动画是基于父layer的动画之上实现的，比如父layer的动画速度是2，子layer也是2的画，那子layer的绝对速度就是4。所以必须要有父layer的动画支持，子layer的动画才能正确实现。但是就算是为了正确性，layer难道不能共用么？上面的例子比如只要一个LOTLayerView3是不是就有正确的动画效果了。  </p>
<p>为了验证我的这个想法，我决定在Lottie的github上发个issue问一下，迟点有答复了再来更新这篇文章。  </p>
<p>好了，LOTLayerView里的layer也基本构建完成，还差最后的往layer添加animation的环节，Lottie的解读也就完成了！但是在那之前，我们还有个麻烦需要解决，那就是刚刚标记了2⃣️的代码块。  </p>
<p>这段代码里，涉及到了AnimatableLayer文件夹下除了LOTLayerView的以外的layer，这是因为LOTLayer里还会有一些形状变化类型的动画数据，存储在LOTLayer.shapes里，这些数据又被封装好在Models文件夹的各种类里。原因是因为一个最顶层的LOTLayer对应的layer只负责一些简单的比如透明度，位置，锚点，仿射变换，旋转等等的keypath动画，还有一些不规则的形变或者色变型动画则存于shapes里，每一种做一个单独的图层，最后添加到LOTLayerView之上，最终形成一个完整的动画图层。  </p>
<p>画条分割线，深呼吸一下，再来看看添加动画的过程吧！  </p>
<hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)_buildAnimations &#123;</div><div class="line">  <span class="built_in">NSMutableDictionary</span> *keypaths = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">  <span class="keyword">if</span> (_layerModel.opacity) &#123;</div><div class="line">    [keypaths setValue:_layerModel.opacity forKey:<span class="string">@"opacity"</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (_layerModel.position) &#123;</div><div class="line">    [keypaths setValue:_layerModel.position forKey:<span class="string">@"position"</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (_layerModel.anchor) &#123;</div><div class="line">    [keypaths setValue:_layerModel.anchor forKey:<span class="string">@"anchorPoint"</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (_layerModel.scale) &#123;</div><div class="line">    [keypaths setValue:_layerModel.scale forKey:<span class="string">@"transform"</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (_layerModel.rotation) &#123;</div><div class="line">    [keypaths setValue:_layerModel.rotation forKey:<span class="string">@"sublayerTransform.rotation"</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (_layerModel.positionX) &#123;</div><div class="line">    [keypaths setValue:_layerModel.positionX forKey:<span class="string">@"position.x"</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (_layerModel.positionY) &#123;</div><div class="line">    [keypaths setValue:_layerModel.positionY forKey:<span class="string">@"position.y"</span>];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">  _animation = [<span class="built_in">CAAnimationGroup</span> LOT_animationGroupForAnimatablePropertiesWithKeyPaths:keypaths];</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (_animation) &#123;</div><div class="line">    [_childContainerLayer addAnimation:_animation forKey:<span class="string">@"LottieAnimation"</span>];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//省略一段关于淡入淡出动画的代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lottie最终使用了CAKeyframeAnimation来生成动画。而我们知道CAKeyframeAnimation被用于CALayer之上，是一种用keypath来生成的动画。这个_build方法的开头就给出一个塞入了keypath的字典，@”opacity”用来控制layer的透明度变化、@”position”用来控制layer的位置变化……如此类推。但是值得注意的是这个字典里的value全都是AnimatableProperties文件夹下的类，而这些properties都有个特征，就是它们都遵循于<code>&lt;LOTAnimatableValue&gt;</code>协议，满足这个协议使得这些property必须具有从数据转换成CAKeyframeAnimation的能力。  </p>
<p>了解了这些，接着让我们来看Lottie里的一个CAAnimationGroup的类别，里面有一个方法:<br><code>+ (nullable CAAnimationGroup *)LOT_animationGroupForAnimatablePropertiesWithKeyPaths:(nonnull NSDictionary&lt;NSString *, id&lt;LOTAnimatableValue&gt;&gt; *)properties;</code><br>也是上面代码块中被用来生成_animation的方法。这个方法通过将LOTLayer下的animatableProperties转化成一个个CAKeyframeAnimation并将它们加到一个CAAnimationGroup里，最后返还结果。这个方法就是将数据变成动画的方法。那么layer有了，动画有了，Lottie也完成了。  </p>
<h3 id="最后，我们来讲讲Lottie的设计模式"><a href="#最后，我们来讲讲Lottie的设计模式" class="headerlink" title="最后，我们来讲讲Lottie的设计模式"></a>最后，我们来讲讲Lottie的设计模式</h3><h4 id="迅速将数据转换为动画的统一接口模式"><a href="#迅速将数据转换为动画的统一接口模式" class="headerlink" title="迅速将数据转换为动画的统一接口模式"></a>迅速将数据转换为动画的统一接口模式</h4><p>先来讲讲Lottie里一个比较有趣的设计模式——AnimatableProperties文件夹下的所有类都遵循于<code>&lt;LOTAnimatableValue&gt;</code>，实现其中的<code>-(CAKeyframeAnimation *)animationForKeypath:(NSString *)keypath</code>便于方便和快速地将数据转化为CAKeyframeAnimation。<br><img src="/images/Lottie——AnimatableProperties设计模式.png" alt="">  </p>
<h4 id="Lottie的整体架构"><a href="#Lottie的整体架构" class="headerlink" title="Lottie的整体架构"></a>Lottie的整体架构</h4><p>由于涉及到的类众多，而Lottie也用文件夹区分好了这些类，那我在介绍Lottie的整体架构的时候就不用类名而用Lottie的文件夹名来做解释吧。首先，JSON从LOTAnimationView进入（这里没办法，文件夹名没很好的表达出这个类的意思）。然后进入到Models解析并存储，紧接着利用Models初始化AnimatableLayers，AnimatableLayers在初始化过程中利用传入的Models里的AnimatableProperties生成CAKeyframeAnimation添加到自身之上，最后返还给LOTAnimationView，这就是整个Lottie的运作机制。  </p>
<p>上个整体架构图：<br><img src="/images/Lottie整体架构图.png" alt=""><br>那么，拼图完整了，Lottie解读完毕！</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    
    <a class="pull-right" href="/2016/12/07/IBOutlet为什么默认是weak的？到底应该设置成strong还是weak？/">
        IBOutlet为什么默认是weak的？到底应该设置成strong还是weak？ →
    </a>
    
</nav>

        <div class="duoshuo">
<div class="ds-thread" data-thread-key="2017/02/26/最近非常火的动画库——Lottie源码解读/" data-title="最近非常火的动画库——Lottie源码解读" data-url="http://yoursite.com/2017/02/26/最近非常火的动画库——Lottie源码解读/"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"duoshuo_name"};
(function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
	 || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Turtle. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/dark19940411" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                    <li><a href="http://weibo.com/1950154683/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
        
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };
    
    resizeHero();
    
    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
